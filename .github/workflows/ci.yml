# Standardized CI/CD Template for Crossplane Providers
# Version: 2025-09-26 - Updated for Go 1.25.1
#
# This template implements CI builds and validates ONLY
# - CI: Build validation only (no publishing to avoid tag conflicts)
# - Release: All publishing handled by release-template.yml
#
# Apply this pattern across all providers to eliminate tag conflicts

name: CI

on:
  push:
    branches:
      - master
      - release-*
  pull_request:
    branches:
      - master
      - release-*
  workflow_dispatch:

permissions:
  contents: read
  packages: write  # Needed for security scanning uploads
  id-token: write  # Needed for OIDC
  actions: read    # Needed for detecting duplicate actions

env:
  GO_VERSION: '1.25.1'
  GOLANGCI_VERSION: 'latest'
  GOLANGCILINT_VERSION: '2.4.0'
  DOCKER_BUILDX_VERSION: 'v0.11.2'

jobs:
  detect-noop:
    runs-on: ubuntu-24.04
    outputs:
      noop: ${{ steps.noop.outputs.should_skip }}
    steps:
      - name: Detect No-op Changes
        id: noop
        uses: fkirc/skip-duplicate-actions@v5.3.0
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          paths_ignore: '["**.md", "**.png", "**.jpg"]'
          do_not_skip: '["workflow_dispatch", "schedule", "push"]'

  lint:
    runs-on: ubuntu-24.04
    needs: detect-noop
    if: needs.detect-noop.outputs.noop != 'true'
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: true

      - name: Setup Go
        uses: actions/setup-go@v6
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Vendor Dependencies
        run: go mod vendor

      - name: Lint
        run: make lint

  check-diff:
    runs-on: ubuntu-24.04
    needs: detect-noop
    if: needs.detect-noop.outputs.noop != 'true'
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: true

      - name: Setup Go
        uses: actions/setup-go@v6
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Vendor Dependencies
        run: go mod vendor

      - name: Check Diff
        run: |
          make reviewable
          git diff --exit-code

  # Comprehensive Testing Suite - leverages our testing framework
  comprehensive-tests:
    runs-on: ubuntu-24.04
    needs: detect-noop
    if: needs.detect-noop.outputs.noop != 'true'
    strategy:
      matrix:
        test-type: [unit, integration, benchmark, e2e]
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: true
          fetch-depth: 0

      - name: Setup Go
        uses: actions/setup-go@v6
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Vendor Dependencies
        run: go mod vendor

      - name: Run Comprehensive Unit Tests
        if: matrix.test-type == 'unit'
        run: |
          echo "🧪 Running comprehensive unit tests..."
          go test ./... -v -race -coverprofile=unit-coverage.out | grep -E "(PASS|FAIL|RUN)"
          echo "📊 Unit test coverage summary:"
          go tool cover -func=unit-coverage.out | tail -1

      - name: Run Integration Tests
        if: matrix.test-type == 'integration'
        run: |
          echo "🔗 Running integration tests..."
          go test ./test/integration -v -coverprofile=integration-coverage.out
          echo "📊 Integration test coverage summary:"
          go tool cover -func=integration-coverage.out | tail -1

      - name: Run Performance Benchmarks
        if: matrix.test-type == 'benchmark'
        run: |
          echo "⚡ Running performance benchmarks..."
          go test ./test/benchmark -v -bench=. -benchmem > benchmark-results.txt
          echo "📈 Benchmark Results Summary:"
          cat benchmark-results.txt

      - name: Run E2E Tests
        if: matrix.test-type == 'e2e'
        run: |
          echo "🚀 Running end-to-end tests..."
          go test ./test/e2e -v -timeout=30m

      - name: Upload Coverage Reports
        if: matrix.test-type == 'unit' || matrix.test-type == 'integration'
        uses: codecov/codecov-action@v4
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          file: ./${{ matrix.test-type }}-coverage.out
          flags: ${{ matrix.test-type }}
          verbose: true

      - name: Upload Test Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: test-results-${{ matrix.test-type }}
          path: |
            ${{ matrix.test-type }}-coverage.out
            benchmark-results.txt
        if: always()

  # Performance Regression Detection
  performance-analysis:
    runs-on: ubuntu-24.04
    needs: comprehensive-tests
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v6
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Download Benchmark Results
        uses: actions/download-artifact@v4
        with:
          name: test-results-benchmark
        continue-on-error: true

      - name: Analyze Performance Metrics
        run: |
          echo "📊 Analyzing performance metrics and regression detection..."

          if [ ! -f "benchmark-results.txt" ]; then
            echo "No benchmark results found, skipping analysis"
            exit 0
          fi

          # Create performance analysis script
          cat > analyze_performance.go << 'EOF'
          package main

          import (
            "bufio"
            "fmt"
            "os"
            "regexp"
            "strconv"
            "strings"
          )

          func main() {
            file, err := os.Open("benchmark-results.txt")
            if err != nil {
              fmt.Printf("No benchmark results found, skipping analysis\n")
              return
            }
            defer file.Close()

            scanner := bufio.NewScanner(file)
            benchmarkRegex := regexp.MustCompile(`Benchmark(\w+)-\d+\s+(\d+)\s+([\d.]+)\s+ns/op`)

            fmt.Println("📈 Performance Analysis Results:")
            fmt.Println("==================================")

            totalBenchmarks := 0
            slowBenchmarks := 0

            for scanner.Scan() {
              line := scanner.Text()
              if strings.Contains(line, "PASS") || strings.Contains(line, "Benchmark") {
                matches := benchmarkRegex.FindStringSubmatch(line)
                if len(matches) == 4 {
                  name := matches[1]
                  iterations := matches[2]
                  nsPerOp, _ := strconv.ParseFloat(matches[3], 64)

                  totalBenchmarks++
                  status := "✅ PASS"

                  // Performance thresholds based on our targets
                  if nsPerOp > 10000000 { // 10ms
                    status = "⚠️  SLOW"
                    slowBenchmarks++
                  }
                  if nsPerOp > 50000000 { // 50ms
                    status = "❌ FAIL"
                    slowBenchmarks++
                  }

                  fmt.Printf("%-25s %s (iters: %s, latency: %.2fms)\n",
                    name, status, iterations, nsPerOp/1000000)
                }
              }
            }

            fmt.Printf("\n📊 Analysis Summary:\n")
            fmt.Printf("Total benchmarks: %d\n", totalBenchmarks)
            fmt.Printf("Slow/failed benchmarks: %d\n", slowBenchmarks)

            if totalBenchmarks > 0 {
              successRate := float64(totalBenchmarks-slowBenchmarks) / float64(totalBenchmarks) * 100
              fmt.Printf("Performance success rate: %.1f%%\n", successRate)

              if successRate < 80 {
                fmt.Printf("⚠️  Performance regression detected!\n")
                os.Exit(1)
              }
            } else {
              fmt.Printf("No benchmark data found to analyze\n")
            }

            fmt.Printf("✅ Performance analysis completed successfully\n")
          }
          EOF

          go run analyze_performance.go
  security-scan:
    runs-on: ubuntu-24.04
    needs: detect-noop
    if: needs.detect-noop.outputs.noop != 'true'
    permissions:
      contents: read
      security-events: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: true

      - name: Setup Go
        uses: actions/setup-go@v6
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Vendor Dependencies
        run: go mod vendor

      - name: Run Go Vulnerability Check
        run: |
          go install golang.org/x/vuln/cmd/govulncheck@latest
          govulncheck ./...

      - name: Run Gosec Security Scanner
        uses: securego/gosec@master
        with:
          args: '-no-fail -fmt sarif -out gosec-results.sarif ./...'
        continue-on-error: true

      - name: Fix Gosec SARIF format
        if: always() && hashFiles('gosec-results.sarif') != ''
        run: |
          if [ -f gosec-results.sarif ]; then
            jq '.runs[].results[].locations[].physicalLocation.artifactLocation.uri |= if . == null or . == "" then "." else . end' gosec-results.sarif > gosec-results-fixed.sarif
            mv gosec-results-fixed.sarif gosec-results.sarif
          fi

      - name: Upload Gosec Results
        uses: github/codeql-action/upload-sarif@v4
        if: always() && hashFiles('gosec-results.sarif') != ''
        with:
          sarif_file: gosec-results.sarif
          category: gosec

  # CI ONLY VALIDATES BUILDS - NO PUBLISHING
  build-validation:
    runs-on: ubuntu-24.04
    needs: [lint, check-diff, comprehensive-tests, security-scan]
    if: github.ref == 'refs/heads/master'
    permissions:
      contents: read
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: true

      - name: Setup Go
        uses: actions/setup-go@v6
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Vendor Dependencies
        run: go mod vendor

      - name: Validate Build Process
        run: |
          # Validate that all build steps work without publishing
          echo "Repository: ${{ github.repository }}"
          echo "Repository owner: ${{ github.repository_owner }}"

          # Build all artifacts (binaries, images, packages)
          make build.all
          echo "✅ All artifacts built successfully"

          # Verify build artifacts exist
          ls -la _output/bin/linux_amd64/provider 2>/dev/null && echo "✅ Provider binary exists" || echo "❌ Provider binary missing"
          ls -la _output/xpkg/linux_amd64/*.xpkg 2>/dev/null && echo "✅ Crossplane package exists" || echo "❌ Crossplane package missing"

          echo ""
          echo "🎯 Build validation completed successfully"
          echo "📦 All artifacts can be built successfully"
          echo "🏷️  Publishing will occur only on release tag creation"

# Key Principles for this Template:
# 
# 1. CI BUILDS, RELEASE PUBLISHES
#    - CI workflow: Only validates builds (no registry pushes)
#    - Release workflow: Handles all publishing
#    - Eliminates tag conflicts between workflows
# 
# 2. SINGLE PRIMARY REGISTRY
#    - Primary: ghcr.io/rossigee (consistent across all providers)
#    - Optional: Environment-controlled additional registries
# 
# 3. PARALLEL VALIDATION
#    - All validation jobs run in parallel after noop detection
#    - Build validation only runs on master branch
# 
# 4. COMPREHENSIVE SECURITY
#    - govulncheck: Go vulnerability scanning
#    - gosec: Static security analysis
#    - CodeQL integration for SARIF uploads
# 
# 5. STANDARDIZED BUILD SYSTEM
#    - Uses rossigee/build submodule (working fork)
#    - Consistent make targets across all providers
#    - Go 1.24.5 with proper version handling
# 
# To apply this template:
# 1. Copy this structure to .github/workflows/ci.yml
# 2. Update provider-specific names/paths
# 3. Ensure release.yml handles all publishing
# 4. Test with a commit to master (should only validate)
# 5. Test with a version tag (should publish properly)